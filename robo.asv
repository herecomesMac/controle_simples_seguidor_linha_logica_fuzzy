%
% Trabalho de Logica Nebulosa
% Guiar um robo por uma linha reta 
%
% Autores:  Marcos Augusto Nolasco do Amaral
%           Patricia Martins Rocca Crestani
%           Thales de Souza Machado

close all
clear all
clc

% Não mostrar as mensagens de Warning
warning off all

vetor_passo = [];
vetor_angulo = [];

% Variaveis que definem o "mundo virtual"
yi=0; yf=100;
xi=0; xf=100;

% Plotagem do "mundo virtual"
Axis = ([xi xf yi yf]);
plot([xi xf xf xi xi],[yi yi yf yf yi]);

% Variaveis para plotagem da linha
yLinha = 3; % Altura da linha que o robo ira seguir
plot_line(0, 100, yLinha, yLinha);
hold on;

fprintf('=>  SISTEMA DE CONTROLE DO ROBO  <= \n \n');
tmp_arq = readfis('roboSeguidorLinha');

controle_passo = 0;
distanciaSensores = 2;
xSensor1 = 0;
xSensor2 = 20;
ySensor1 = 13;
ySensor2 = -13;
xCentro = (xSensor2 + xSensor1) / 2;
yCentro = (ySensor2 + ySensor1) / 2;
plot(xCentro, yCentro);
plot_line(xSensor1, xSensor2, ySensor1, ySensor2);
t = text(xCentro, yCentro, string(controle_passo));
hold on;
% Comentando caso a gente queira usar input
%yc = input('Qual a posicao y inicial do robo? (6 <= y <= 94) => ');
%ymin1 = yi + r;     % Valor minimo da ordenada inicial do robo
%ymax1 = yf - r;     % Valor maximo da ordenada inicial do robo
%while yc < ymin1 | yc > ymax1 
%    yc = input('Posicao invalida! Entre com um novo valor entre 6 e 94  => ');
%end

axis([0 100 0 100]);

% Comentando caso a gente queira usar input
% Angulo do robo com a horizontal - variavel phi
%phii=-90; phif=90;
%phi = input('Qual o angulo inicial com a linha horizontal? (-90 <= angulo <= 90) =>');
%while phi < phii | phi > phif
%    phi = input('Angulo invalido! Entre com um novo valor entre -90 e 90 => ');
%end

% Passos para o robo atingir a outra parede
n_passos = 0;

% Posicao x que o robo deve atingir, ou seja, a parede lateral direita
xmeta = 100;

erro = 0.05;

% Passo que o robo andara
passo = 1;

dist = 100;

% Controle de movimentação do robô caso as regras não o façam
% movimentar pelo mundo virtual

xSensor = (4 * cos(30)) - (3 * sin(30));
ySensor = (4 * sin(30)) + (3 * cos(30));
fprintf("Sensor fake: %d %d", xSensor, ySensor);

while(xCentro < 100)
   %verificar divisao por 0
   coeficienteAngular = (ySensor2 - ySensor1)/(xSensor2 - xSensor1);
   fprintf("Coeficiente angular %d \n", coeficienteAngular);
   arctan = atan(coeficienteAngular);
   arctan_deg = arctan * (180/pi);
   fprintf("Arctan %f \n", arctan_deg);
   fprintf("yCentro %f \n", yCentro);
   saida = evalfis([arctan_deg yCentro], tmp_arq);
   anguloCorrecao = (saida(1) * pi)/180; (pi*phi)/180;
   fprintf("Angulo correcao %f \n", anguloCorrecao);
   
   xSensor1Passado = xSensor1;
   xSensor2Passado = xSensor2;
   ySensor1Passado = ySensor1;
   ySensor2Passado = ySensor2;
   
   xSensor1 = (xSensor1Passado * cos(anguloCorrecao)) - (ySensor1Passado * sin(anguloCorrecao));
   ySensor1 = (xSensor1Passado * sin(anguloCorrecao)) + (ySensor1Passado * cos(anguloCorrecao));
   xSensor2 = (xSensor2Passado * cos(anguloCorrecao)) - (ySensor2Passado * sin(anguloCorrecao));
   ySensor2 = (xSensor2Passado * sin(anguloCorrecao)) + (ySensor2Passado * cos(anguloCorrecao));
   
   
   xSensor1 = xSensor1 + 10;
   xSensor2 = xSensor2 + 10;
   fprintf("xSensor1 %f \n", xSensor1);
   xCentro = (xSensor1 + xSensor2) /2;
   yCentro = (ySensor1 + ySensor2) /2;
   
   plot(xCentro, yCentro);
   plot_line(xSensor1, xSensor2, ySensor1, ySensor2);
   controle_passo = controle_passo + 1;
   t = text(xCentro, yCentro, string(controle_passo));
   pause(0.0005);
end

